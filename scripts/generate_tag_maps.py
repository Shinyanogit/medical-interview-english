#!/usr/bin/env python3
"""Generate client-side tag maps so inline links stay within the restored HTML set."""
from __future__ import annotations

import csv
import json
import sqlite3
from pathlib import Path
from typing import Dict, Iterable, Tuple

REPO_ROOT = Path(__file__).resolve().parents[1]

BOOKS = [
    {
        "name": "1AM1100",
        "root": REPO_ROOT / "local/restored/1AM1100/S1",
        "source": {
            "type": "sqlite",
            "path": "tag.db",
        },
    },
    {
        "name": "1AM2100",
        "root": REPO_ROOT / "local/restored/1AM2100/S2",
        "source": {
            "type": "csv",
            "path": "s2_tags.csv",
        },
    },
]


def build_file_lookup(book_root: Path) -> Dict[str, str]:
    lookup: Dict[str, str] = {}
    duplicates = set()
    for html_path in book_root.rglob("*.html"):
        rel = html_path.relative_to(book_root).as_posix()
        name = html_path.name
        if name in lookup:
            duplicates.add(name)
            continue
        lookup[name] = rel
    if duplicates:
        print(f"[warn] Duplicate file names under {book_root}: {sorted(duplicates)[:5]}...")
    return lookup


def iter_rows(book: dict) -> Iterable[Tuple[str, str]]:
    source = book["source"]
    path = book["root"] / source["path"]
    if source["type"] == "csv":
        with path.open(newline="", encoding="utf-8") as fh:
            reader = csv.reader(fh)
            for row in reader:
                if not row:
                    continue
                tag_id = row[0].strip()
                file_name = row[1].strip()
                if not tag_id or not file_name:
                    continue
                yield tag_id, file_name
    elif source["type"] == "sqlite":
        conn = sqlite3.connect(path)
        try:
            for tag_id, file_name in conn.execute("SELECT id, file FROM tag_tbl"):
                if not tag_id or not file_name:
                    continue
                yield tag_id, file_name
        finally:
            conn.close()
    else:
        raise ValueError(f"Unknown source type: {source['type']}")


def build_tag_map(book: dict) -> Dict[str, str]:
    lookup = build_file_lookup(book["root"])
    tag_map: Dict[str, str] = {}
    missing = 0
    for tag_id, file_name in iter_rows(book):
        rel = lookup.get(file_name)
        if rel is None:
            missing += 1
            continue
        tag_map[tag_id] = rel
    if missing:
        print(f"[warn] {book['name']}: {missing} tag entries had no matching file")
    print(f"[info] {book['name']}: mapped {len(tag_map)} tags")
    return tag_map


def write_js(tag_map: Dict[str, str], output_path: Path) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as fh:
        fh.write("// Auto-generated by generate_tag_maps.py. Do not edit manually.\n")
        fh.write("window.__MEDILINK_TAG_MAP = ")
        json.dump(tag_map, fh, ensure_ascii=False, separators=(",", ":"))
        fh.write(";\n")


def main() -> None:
    for book in BOOKS:
        tag_map = build_tag_map(book)
        out_path = book["root"] / "js" / "tagmap.js"
        write_js(tag_map, out_path)
        print(f"[info] Wrote {out_path.relative_to(REPO_ROOT)}")


if __name__ == "__main__":
    main()
